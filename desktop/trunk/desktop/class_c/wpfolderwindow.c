/* ***** BEGIN LICENSE BLOCK *****
* Version: CDDL 1.0/LGPL 2.1
*
* The contents of this file are subject to the COMMON DEVELOPMENT AND
* DISTRIBUTION LICENSE (CDDL) Version 1.0 (the "License"); you may not use
* this file except in compliance with the License. You may obtain a copy of
* the License at http://www.sun.com/cddl/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
* for the specific language governing rights and limitations under the
* License.
*
* The Original Code is "NOM" Netlabs Object Model
*
* The Initial Developer of the Original Code is
* netlabs.org: Chris Wohlgemuth <cinc-ml@netlabs.org>.
* Portions created by the Initial Developer are Copyright (C) 2005-2006
* the Initial Developer. All Rights Reserved.
*
* Contributor(s):
*
* Alternatively, the contents of this file may be used under the terms of
* the GNU Lesser General Public License Version 2.1 (the "LGPL"), in which
* case the provisions of the LGPL are applicable instead of those above. If
* you wish to allow use of your version of this file only under the terms of
* the LGPL, and not to allow others to use your version of this file under
* the terms of the CDDL, indicate your decision by deleting the provisions
* above and replace them with the notice and other provisions required by the
* LGPL. If you do not delete the provisions above, a recipient may use your
* version of this file under the terms of any one of the CDDL or the LGPL.
*
* ***** END LICENSE BLOCK ***** */
/*
 * This file was generated by orbit-idl-2 for Voyager
 *
 */
#ifndef NOM_WPFolderWindow_IMPLEMENTATION_FILE
#define NOM_WPFolderWindow_IMPLEMENTATION_FILE
#endif

#define INCL_DOS

#define METHOD_DEBUG

#include <os2.h>

#include <nom.h>
#include <nomtk.h>

#include <string.h>
#include <gtk/gtk.h>
#include "nomguitk.h"
#include "nomwindow.h"
#include "desktoptypes.h"

#include "wpnotebook.h"
#include "wpfolderwindow.h"
#include "wpfolder.h"
#include "wpfolderwindow.ih"
#include "wpobject.h"
#include "exception.h"

NOM_Scope PGtkWidget NOMLINK impl_WPFolderWindow_wpQueryContainerHandle(WPFolderWindow* nomSelf, CORBA_Environment *ev)
{
  WPFolderWindowData* nomThis=WPFolderWindowGetData(nomSelf);

  return (PGtkWidget) g_atomic_pointer_get(&_pgContainerHandle);
}

NOM_Scope void NOMLINK impl_WPFolderWindow_wpSetContainerHandle(WPFolderWindow* nomSelf, const PGtkWidget pgWidget,
                                                              CORBA_Environment *ev)
{
  WPFolderWindowData* nomThis=WPFolderWindowGetData(nomSelf);

  _pgContainerHandle=pgWidget;
}

/*
  Check if the right button click was within a certain time. That means
  the user released the button again within a short time period. On OS/2
  a context menu will display after the user released the button not when
  the user pressed it.
 */
#define CTXT_MENU_BUTTON_DELAY 250
static gboolean
fldr_checkContextButton(GdkEventButton *event)
{
  static guint guiTime=0;

  /* Right mouse button */
  if (event->button != 3)
    return FALSE;

  /* Ignore double-clicks and triple-clicks */
  if(event->type == GDK_BUTTON_PRESS)
    guiTime=event->time;

  if(event->type == GDK_BUTTON_RELEASE)
    {
      if(event->time-guiTime<CTXT_MENU_BUTTON_DELAY)
        return TRUE;
    }

  return FALSE;
}

static gboolean
fldr_handleButtonEvent (GtkWidget *widget, GdkEventButton *event, gpointer user_data)
{
  

  TRY(FLDR_BUTTONEVENT) {
    if(fldr_checkContextButton(event))
      {
        PWPFolderWindow pWindow;
        GtkTreePath* treePath;
        //DosBeep(5000, 100);
        pWindow=(WPFolderWindow*)user_data;
        //TST_OBJECT(pWindow);
        treePath=gtk_icon_view_get_path_at_pos(GTK_ICON_VIEW(widget), event->x, event->y );
        if(NULL==treePath)
          {
            /* Click on white space */
            WPFolder* wpFolder;
            wpFolder=(WPFolder*)WPFolderWindow_wpQueryWPObject(pWindow, NULLHANDLE);
            TST_OBJECT(wpFolder);
            
            if(nomIsObj(wpFolder))
              WPObject_wpDisplayMenu((WPObject*)wpFolder, pWindow, NULL, MENU_OPENVIEWPOPUP, 0, NULL);
            else
              g_message("%d %s: WPFolder object not valid!", __LINE__, __FUNCTION__);
          }
        else
          {
            GtkTreeIter iter;
            GtkTreeModel* model;
            WPObject *wpObject;
            /* Click on an icon */
            
            g_message("%s: %s", __FUNCTION__, gtk_tree_path_to_string(treePath));
            
            model=gtk_icon_view_get_model(GTK_ICON_VIEW(widget));
            g_message("%s: model: %x", __FUNCTION__, (UINT)model);
            
            gtk_tree_model_get_iter(model , &iter, treePath);            
            gtk_tree_model_get(model, &iter, 0, &wpObject, -1);

            TST_OBJECT(wpObject);

            if(nomIsObj(wpObject)){
              g_message("%s: %s calling wpDisplayMenu()", __FUNCTION__, wpObject->mtab->nomClassName);
              WPObject_wpDisplayMenu((WPObject*)wpObject, pWindow, NULL, MENU_OBJECTPOPUP, 0, NULL);
            }
            else
              g_message("%d %s: WPDataFile object not valid!", __LINE__, __FUNCTION__);

          }
      }/* if() */
  }CATCH{    
    //LOUD;
    g_message("Line %d: Trap in %s", __LINE__, __FUNCTION__);  
  }  END_CATCH(FLDR_BUTTONEVENT);

  return FALSE;
}

static gboolean fldrWindowHandleDragDrop(GtkWidget * widget, GdkDragContext* dragContext, gint x, gint y,
                         guint t, gpointer ptrUserData)
{
  DosBeep(2500, 10);
  DosBeep(500, 10);
  DosBeep(2500, 10);
  g_message("%s", __FUNCTION__);
  return FALSE;
}

#if 0
static void fldrDragLeave(GtkWidget * widget, GdkDragContext* dragContext,
                          guint t, gpointer ptrUserData)
{
  GdkPixmap *pixMapDrag;
  
  gdk_pixbuf_render_pixmap_and_mask(pixBufStop, &pixMapDrag, NULL, 128);
  gdk_window_set_back_pixmap(wgtDrag->window, pixMapDrag, FALSE);
  g_object_unref(pixMapDrag);
  gtk_widget_queue_draw(wgtDrag);

  g_message("%s", __FUNCTION__);

  return;
}
#endif

static GtkWidget *wgtDrag=NULL;

static GdkPixmap *pixMapDrag=NULL;
static GdkPixmap *pixMapStop=NULL;

/*
  Callback which loads a pixmap into the drag widget as soon as it#s realized.
 */
static void fldrWidgetRealize(GtkWidget * wgtDrag, gpointer ptrUserData)
{
  gdk_window_set_back_pixmap(wgtDrag->window, pixMapDrag, FALSE);

  g_message("%s", __FUNCTION__);
  return;
}

static void fldrWindowHandleDragBegin(GtkWidget * widget, GdkDragContext* dragContext,
                    gpointer ptrUserData)
{
  if(NULLHANDLE==wgtDrag)
    {
      GdkPixbuf *pixBufDrag;
      GdkPixbuf *pixBufStop;

      wgtDrag=gtk_window_new(GTK_WINDOW_POPUP);

      /*
        FIXME:
        In GTK 2.8 use *_HINT_DND instead.
       */
#warning move this somewhere else. Maybe into WPClassMgr 
      gtk_window_set_type_hint(GTK_WINDOW(wgtDrag), GDK_WINDOW_TYPE_HINT_MENU);
      gtk_widget_set_app_paintable(GTK_WIDGET(wgtDrag), TRUE);

      pixBufDrag=gtk_widget_render_icon(wgtDrag, GTK_STOCK_DND, GTK_ICON_SIZE_DND, NULL);
      gdk_pixbuf_render_pixmap_and_mask(pixBufDrag, &pixMapDrag, NULL, 128);

      gtk_widget_set_size_request(wgtDrag, gdk_pixbuf_get_width(pixBufDrag), gdk_pixbuf_get_height(pixBufDrag));

      g_object_unref(pixBufDrag);

      pixBufStop=gtk_widget_render_icon(wgtDrag, GTK_STOCK_STOP, GTK_ICON_SIZE_DND, NULL);
      gdk_pixbuf_render_pixmap_and_mask(pixBufStop, &pixMapStop, NULL, 128);
      g_object_unref(pixBufStop);

      if(!pixMapDrag)
        g_warning("Cannot load pixbuf");
      if(!pixMapStop)
        g_warning("Cannot load stop pixbuf");

      //      gdk_pixbuf_render_pixmap_and_mask(pixBufDrag, &pixMapDrag, NULL, 128);
      //    gdk_window_set_back_pixmap(wgtDrag->window, pixMapDrag, FALSE);
      //      g_object_unref(pixMapDrag);
      g_signal_connect_after(GTK_WIDGET(wgtDrag), "realize", G_CALLBACK(fldrWidgetRealize), NULL);
    }
  DosBeep(1000, 10);
  g_message("%s", __FUNCTION__);
  //  if(wgtDrag->window)
  //gdk_window_set_back_pixmap(wgtDrag->window, pixMapDrag, FALSE);

  gtk_drag_set_icon_widget(dragContext, wgtDrag, 0, 0);

  return;
}

static gboolean fldrWindowHandleDragMotion(GtkWidget * wgtThis, GdkDragContext* dragContext, int x, int y, guint t,
                    gpointer ptrUserData)
{
  GtkWidget *wgtSource;
  GtkTreePath* treePath;
  PWPFolderWindow pWindow;
  gulong rc=0;
  static gulong oldRc=0;

  if(dragContext==NULL)
    return FALSE;

  if((wgtSource=gtk_drag_get_source_widget(dragContext))==NULLHANDLE)
    return FALSE;

#if 0
  if(wgtSource==wgtThis){
    gdk_drag_status(dragContext, GDK_ACTION_MOVE, t);
    //    gdk_drag_status(dragContext, 0, t);
    gtk_drag_highlight(wgtThis);
  }
  else{
    gdk_drag_status(dragContext, GDK_ACTION_COPY, t);
    gtk_drag_unhighlight(wgtSource);
  }
#endif

  treePath=gtk_icon_view_get_path_at_pos(GTK_ICON_VIEW(wgtThis), x, y );

  if(NULL==treePath)
    {      
      PWPFolder wpFolder;
      /* White space */

      pWindow=(WPFolderWindow*)ptrUserData;
      if(!nomIsObj(pWindow))
        return FALSE;

      wpFolder=(WPFolder*)WPFolderWindow_wpQueryWPObject(pWindow, NULLHANDLE);     

      if(!nomIsObj(wpFolder))
        return FALSE;

      rc=WPObject_wpDragOver((WPObject*)wpFolder, wgtThis, dragContext, NULL);
    }
  else
    {
      GtkTreeIter iter;
      GtkTreeModel* model;
      WPObject *wpObject;
      /* Over an icon */
      
      //   g_message("%s: %s", __FUNCTION__, gtk_tree_path_to_string(treePath));
      //    gtk_icon_view_item_activated(GTK_ICON_VIEW(wgtThis), treePath);

      model=gtk_icon_view_get_model(GTK_ICON_VIEW(wgtThis));
            
      gtk_tree_model_get_iter(model , &iter, treePath);            
      gtk_tree_model_get(model, &iter, 0, &wpObject, -1);

      //TST_OBJECT(wpObject);

      //if(nomIsObj(wpObject))
      rc=WPObject_wpDragOver((WPObject*)wpObject, wgtThis, dragContext, NULL);
    }

  if(oldRc!=rc)
    {
      /* drag icon */
      switch(rc)
        {
        case 0:
          {
            /* Don't drop */    
            gdk_window_set_back_pixmap(wgtDrag->window, pixMapStop, FALSE);
            break;
          }
        default:
          {
            gdk_window_set_back_pixmap(wgtDrag->window, pixMapDrag, FALSE);
            break;
          }
        } 
      gtk_widget_queue_draw(wgtDrag);
    }
  oldRc=rc;

  return FALSE;
}


NOM_Scope void NOMLINK impl_WPFolderWindow_nomInit(WPFolderWindow* nomSelf, CORBA_Environment *ev)
{
  GtkWidget* window;
  GtkWidget *vbox;
  GtkWidget *sw;
  GtkWidget *icon_view;
  GtkWidget *tool_bar;
  GtkToolItem *up_button;
  //  GtkWidget *menuBar, *file;
  //  WPFolderWindowData* nomThis=WPFolderWindowGetData(nomSelf);

  /* Let parents initialize */
  WPFolderWindow_nomInit_parent((NOMObject*)nomSelf, NULLHANDLE);

  /* Create a default (hidden) folder window */

  /* Folder toplevel window. */
  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);

  /* FIXME: Set default size of folder frame. Will later use a stored value */
  gtk_window_set_default_size (GTK_WINDOW (window), 650, 400);

  /* Make sure we have a reference to the class so the garbage collector
     doesn't unload us */
  g_object_set_data(G_OBJECT(window), NOMOBJECT_KEY_STRING, nomSelf);

#if 0
  menuBar=gtk_menu_bar_new();
  file=gtk_menu_item_new_with_label("File");
  //gtk_signal_connect(GTK_OBJECT(file), "destroy", GTK_SIGNAL_FUNC(tst), NULL);

  gtk_container_add(GTK_CONTAINER(menuBar), file);
  gtk_widget_show(menuBar);
  gtk_widget_show(file);
#endif

  vbox = gtk_vbox_new (FALSE, 0);

  gtk_container_add (GTK_CONTAINER (window), vbox);

  /* Create and pack the toolbar */
  tool_bar = gtk_toolbar_new ();
  
  //  gtk_box_pack_start (GTK_BOX (vbox), menuBar, FALSE, FALSE, 0); /* Don't expand the toolbar vertically if sized */
  gtk_box_pack_start (GTK_BOX (vbox), tool_bar, FALSE, FALSE, 0); /* Don't expand the toolbar vertically if sized */
  
  /* Parent button */
  up_button = gtk_tool_button_new_from_stock (GTK_STOCK_GO_UP);
  gtk_tool_item_set_is_important (up_button, TRUE);
  /* Disable button */
  gtk_widget_set_sensitive (GTK_WIDGET (up_button), FALSE);
  /* Put it into the toolbar */
  gtk_toolbar_insert (GTK_TOOLBAR (tool_bar), up_button, -1);
  
  sw = gtk_scrolled_window_new (NULL, NULL);
  /* Drawing style */
  gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (sw),
                                       GTK_SHADOW_ETCHED_IN);
  /* Show scrollbars only if necessary */
  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (sw),
                                  GTK_POLICY_AUTOMATIC,
                                  GTK_POLICY_AUTOMATIC);
  /* Pack it into the vbox with size adjusting to the vbox */
  gtk_box_pack_start (GTK_BOX (vbox), sw, TRUE, TRUE, 0);
  /* Create an icon view without model */
  icon_view = gtk_icon_view_new ();

  /* Allow multiple selection in icon view */
  gtk_icon_view_set_selection_mode (GTK_ICON_VIEW (icon_view),
                                    GTK_SELECTION_MULTIPLE);
#if 0
  /* Connect to the "item_activated" signal */
  g_signal_connect (icon_view, "item-activated",
                    G_CALLBACK (itemActivated), nomSelf);
#endif
  //#endif

  /* This is for kb binding only */
#if 0
  g_signal_connect (GTK_WIDGET(icon_view), "popup-menu",
                    G_CALLBACK (fldr_cbPopupMenu), nomSelf);
#endif

  /* Handle mouse buttons */
  g_signal_connect (GTK_WIDGET(icon_view), "button-press-event",
                    G_CALLBACK (fldr_handleButtonEvent), nomSelf);
  g_signal_connect (GTK_WIDGET(icon_view), "button-release-event",
                    G_CALLBACK (fldr_handleButtonEvent), nomSelf);

  /* Handle folder DnD */
  g_signal_connect(GTK_WIDGET(icon_view),"drag-begin",
                   G_CALLBACK(fldrWindowHandleDragBegin), nomSelf);
  g_signal_connect(GTK_WIDGET(icon_view),"drag-motion",
                   G_CALLBACK(fldrWindowHandleDragMotion), nomSelf);
  g_signal_connect(GTK_WIDGET(icon_view),"drag-drop",
                   G_CALLBACK(fldrWindowHandleDragDrop), nomSelf);


#if 0
  /* Connect to the "clicked" signal of the "Up" tool button */
  g_signal_connect (up_button, "clicked",
                    G_CALLBACK (up_clicked), store);
#endif

  WPFolderWindow_wpSetContainerHandle(nomSelf, icon_view, NULLHANDLE);

  /* Add icon view as child to the scroll window created earlier */
  gtk_container_add (GTK_CONTAINER (sw), icon_view);

  gtk_widget_grab_focus (icon_view);

  //  g_signal_connect (GTK_WIDGET(window), "size-request",
  //                G_CALLBACK (handleEvent), nomSelf);

  WPFolderWindow_setWindowHandle(nomSelf, window, NULLHANDLE);
  /* Window is hidden here and must be shown by the caller */
}


